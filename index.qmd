---
title: "<span class='pref'>Vietoris--Rips Shadow for</span>Geometric Graph Reconstruction"
title-slide-attributes: 
  data-background-image: "drawing.png"
  data-background-opacity: "0.3"
subtitle: <green>Joint Math Meetings, 2026</green>
author: "<b>Sushovan Majhi</b>, *George Washington University, DC*"
fig-cap-location: bottom
callout-icon: false
format: 
    revealjs:
        theme: dark
        slide-number: true
        self-contained: true
        incremental: true
        css: style.css
        navigation-mode: vertical
bibliography: references.bib
editor: 
  render-on-save: true
html-math-method: mathml
---

# The Problem of <green>Shape Reconstruction</green> {background-image="drawing.png" background-opacity="0.3"}


## {.smaller}

```{ojs}
//| panel: sidebar
viewof n = Inputs.range([0, 500], { label: "Sample Size", value: 150, step: 1 })
viewof tol = Inputs.range([0, 100], { label: "Noise", value: 20, step: 1 })
viewof scaleB = Inputs.range([0, 150], {
  step: 0.5,
  value: 0,
  label: tex`r_{S}`
});
viewof scaleA = Inputs.range([0, 150], {
  step: 0.5,
  value: 0,
  label: tex`r_{\mathcal G}`
})
viewof scale = Inputs.range([0, 300], {
  step: 1,
  value: 0,
  label: tex`\beta`
})
viewof showShape = Inputs.toggle({ label: tex`{\mathcal G}`, value: false })
viewof showSample = Inputs.toggle({ label: tex`{S}`, value: false })
viewof showRips = Inputs.toggle({ label: 'Euclidean Vietoris–Rips', value: false })
```

```{ojs}
import { slider } from "@jashkenas/inputs"
{
  const svg = d3
    .create("svg")
    .attr("class", "canvas")
    .style("margin-left", "15px")
    .style("width", "100%")
    .style("height", height);

  if(showShape) {
    svg
      .append("path")
      .attr("class", "shape")
      .attr("stroke", "#3be57f")
      .attr("stroke-width", "2")
      .attr("fill", "none")
      .attr("d", d3.line()(X));
  }

  if(showSample) {
    svg
      .selectAll(".vertex")
      .data(S)
      .join("circle")
      .attr("class", "vertex")
      .attr("fill", "#bb473f")
      .attr("cx", (d) => d[0])
      .attr("cy", (d) => d[1])
      .attr("r", "3px");
  }
  if(scaleA > 0 || scaleB > 0)
    drawBalls(svg, X, S, scaleA, scaleB); 
  if(showRips)
    drawRips(svg, rips(S, scale));
  
  return svg.node();
}
rips = function (sample, scale) {
	const simplices=[d3.range(sample.length),[],[]];
	const adjRips = new Array(sample.length);
	const dEps = new Array(sample.length);
	
	for(var i = 0; i < adjRips.length; i++) {
	    adjRips[i]= new Array(sample.length);
	    
	    for(var j = 0; j < adjRips.length; j++) {
		  var d = dist2(sample[i],sample[j]); 
		  if( d < scale) {
		    adjRips[i][j]=d;
		    if(i<j)
    	 		simplices[1].push([i,j]);
		  }
		  else
		    adjRips[i][j]=0;
	    }
	}
	combinations(simplices[0],3).forEach(function(d) {
    	    if ( diam2( d3.permute(sample,d) ) < scale )
    		simplices[2].push(d);
  });
  return simplices;
}

X = lissajous(center, 0, center[0] - 70, center[1] - 50, 3, 2, 2000)
S = lissajous(center, tol, center[0] - 70, center[1] - 50, 3, 2, n)
center = [height / 2 + 100, height / 2]
height = 500
lissajous = function (
  center,
  tol = 5,
  a = center[0] - 100,
  b = center[1] - 50,
  kx = 3,
  ky = 2,
  n = 300
) {
  var t = d3.range(n).map(function (d) {
    return (2 * Math.PI * d) / (n - 1);
  });
  var points = [];
  for (var i = 0; i < n; i++) {
    points[i] = [
      center[0] +
        a * Math.cos(kx * t[i]) +
        d3.randomUniform(tol)() * Math.cos(d3.randomUniform(2 * Math.PI)()),
      center[1] +
        b * Math.sin(ky * t[i]) +
        d3.randomUniform(tol)() * Math.sin(d3.randomUniform(2 * Math.PI)())
    ];
  }
  return points;
}
function dist2(a, b) {
  if (a.length != b.length || a.length != 2) return null;
  return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
}
function diam2(points) {
  var diam = 0;
  points.forEach(function (p) {
    points.forEach(function (q) {
      diam = Math.max(diam, dist2(p, q));
    });
  });
  return diam;
}
function combinations(set, k) {
    var i, j, combs, head, tailcombs;
    if (k > set.length || k <= 0) {
	return [];
    }
    if (k == set.length) {
	return [set];
    }
    if (k == 1) {
	combs = [];
	for (i = 0; i < set.length; i++) {
	    combs.push([set[i]]);
	}
	return combs;
    }
    combs = [];
    for (i = 0; i < set.length - k + 1; i++) {
	head = set.slice(i, i + 1);
	tailcombs = combinations(set.slice(i + 1), k - 1);
	for (j = 0; j < tailcombs.length; j++) {
	    combs.push(head.concat(tailcombs[j]));
	}
    }
    return combs
}
drawBalls = function (svg, X, S, scaleA, scaleB) {
  svg
    .selectAll(".A-ball")
    .data(X)
    .join("circle")
    .attr("class", "A-ball")
    .attr("cx", (d) => d[0])
    .attr("cy", (d) => d[1])
    .attr("r", scaleA)
    .attr("fill", "#3be57f")
    .attr("stroke", "none")
    .attr("opacity", "0.1");
  svg
    .selectAll(".B-ball")
    .data(S)
    .join("circle")
    .attr("class", "B-ball")
    .attr("cx", (d) => d[0])
    .attr("cy", (d) => d[1])
    .attr("r", scaleB)
    .attr("fill", "#bb473f")
    .attr("stroke", "none")
    .attr("opacity", "0.1");
  
  return svg;
}
drawRips = function (svg, simplices) {

  if (simplices[2]) {
    svg.selectAll(".triangle")
      .data(simplices[2])
      .join("path")
      .attr("class", "triangle")
      .attr("d", (d) => d3.line()(d.map((v) => S[v])))
      .attr("fill", "#bb473f")
      .attr("stroke", "none")
      .attr("opacity", "0.1");
  }
  if (simplices[1]) {
    svg.selectAll(".edge")
      .data(simplices[1])
      .join("path")
      .attr("class", "edge")
      .attr("d", (d) => d3.line()(d.map((v) => S[v])))
      .attr("stroke", "#bb473f").attr("stroke-width", "1.5");
  }
  return svg;
}
```

## M<green>&alpha;</green><green>&theta;</green>ema<green>&tau;&iota;</green>cal Formulation {.smaller}
- <green>**Shape**</green>: A *Shape* is modeled as a metric space
  - Abstract & Euclidean Riemannian manifolds
  - abstract metric graphs
  - <green>*embedded* metric graph ($\mathcal G\subset\mathbb R^N$)</green>

- <green>**Sample**</green>: A *finite* $S\subset\mathbb R^N$ with small <green>Hausdorff</green> distance $d_{\mathrm H}(\mathcal G, S)$
   
- <green>**Goal**</green>: Infer the topology of $\mathcal G$ from $S$.
    - <green>construct</green> a topological space $\hat{\mathcal G}$ (e.g. Vietoris--Rips) from $S$ so that
      - $\hat{\mathcal G}$ is homotopy equivalent to $\mathcal G$ (<green>topological</green> reconstruction)
      - $\hat{\mathcal G}\subset\mathbb R^N$ and $d_{\mathrm H}(\hat{\mathcal G}, S)$ small (<green>geometric</green> reconstruction)
  
# Vietoris<green>--</green>Rips Complexes {background-image="drawing.png" background-opacity="0.3"}


## Definition {.smaller}

::: {.columns}

:::{.column width="65%"}

- a metric space $(X,d_X)$
  
- a scale $\beta>0$ 
  
- $\mathcal{R}_\beta(X)$ is an abstract simplicial complex
   
  - $X$ is the <green>vertex set</green>
  - each <green>subset</green> $A\subset X$ of $(k+1)$ points with <green>diameter</green> less than $\beta$ is a $k$-simplex.

:::

::: {.column width="35%"}
![](single-rips.png)

:::

:::

. . . 

::: {.callout-note appearance="minimal"}

- <gray>Persistent homology considers all possible scales $\beta$ to make reasonable (only) <red>homological</red> inference</gray>

- My goal is to provide a [window] of scales where <green>homotopy</green> properties are guaranteed.

:::

## Why Does Vietoris--Rips Make Sense? {.smaller}

- Computationally efficient
- Data dimension agnostic---unlike the Čech complex or $\alpha$-complex

. . . 

:::{.callout-tip icon="false"}
## @hausmann_1995
For any closed Riemannian manifold $X$ and $0<\beta<\rho(X)$, the Vietoris--Rips complex $\mathcal{R}_\beta(X)$ is *homotopy equivalent* to $X$.
:::

. . .

::: {.callout-tip icon="false"}
## @latschev_2001
Every closed Riemannian manifold $X$ has an <green>$\epsilon_0>0$</green> such that for any $0<\beta\leq\epsilon_0$ there exists some <red>$\delta>0$</red> so that for any sample $S$:
$$
d_{GH}(S,X)\leq\delta\implies \mathcal R_\beta(S)\simeq X.
$$
:::


## Quantitative Latschev's Theorems

- Metric Graphs [@Majhi2023]
- Riemannian Manifolds [@MajhiLatschev]
- $CAT(\kappa)$ Spaces [<code>ArXiv:2406.04259</code>, @2406.04259]


## Vietoris--Rips Complexes in Limits {.smaller}

- $(X, d_X)$ metric space and indexed set: $\mathbb{S}\coloneqq\{S\subset X\ : \lvert S\rvert<\infty\}$ under set inclusion
- For any scale $\beta\geq0$, we have the direct system of groups
$$\left\{\pi_m(\mathcal{R}_\beta(S))\to \pi_m(\mathcal{R}_\beta(T))\mid S,T\in\mathbb{S}, S\subset T\right\}$$

. . .

::: {.callout-tip icon="false"}
## Hausmann in Limits [@Kawamura2026-ob]
The direct limit:
$$
\pi_m(\mathcal{R}_\beta(\mathbb{S}))\coloneq\lim_{S\in\mathbb{S}}\pi_m(\mathcal{R}_\beta(S))\cong \pi_m(\mathcal{R}_\beta(X)).
$$

:::

. . .

::: {.callout-tip icon="false"}
## Latschev in Limits [@Kawamura2026-ob]
Let $D\coloneqq\{ p_{k}\mid k=1,2,\ldots\}$ be a countable dense subset of a separable space $X$ and let $S_{k}\coloneq \{ p_{i}\mid i=1,\ldots, k\}$. 
Then,
$$\lim_{k}\pi_m(\mathcal{R}_\beta(S_{k})) \cong \pi_m(\mathcal{R}_\beta(X)).$$
:::

# Euclidean <green>Graph</green>  Reconstruction {background-image="drawing.png" background-opacity="0.3"}


## Challenges {.smaller}


::: {.columns}

:::{.column width="60%"}

- <red>Unknown Shape</red>: $\mathcal{G}\subset\mathbb R^N$ with geodesic metric $d_\mathcal{G}$
- <green>Sample</green>: $S\subset\mathbb{R}^N$ with Euclidean metric $\|\bullet\|$
- <gray>Density</gray>: $d_H(S,\mathcal{G})$ small or can be controlled
- <green>Q</green>: Find a [range] of $\beta$ so that $\mathcal{R}_\beta(S)$ is homotopy equivalent to $\mathcal{G}$.
:::

::: {.column width="40%"}
![](single-rips.png)

:::

:::

. . . 

::: {.callout-caution appearance="minimal"}
## Bad News :-( 
A *single* Vietoris--Rips complex <red>fails</red> to be topologically faithful, no matter the sample density 

:::

## Remedy 1: <green>$\varepsilon$</green>-path Metric {.smaller}

:::{.columns}
:::{.column width="60%"}

1. Fix a positive <green>$\varepsilon$</green>: <gray>proportional to $d_H(S, \mathcal G)$</gray>;

2. Compute $\varepsilon$-neighborhood graph on $S$: <green>$\mathcal R^{(1)}_\varepsilon(S)$</green>;

3. Define <green>$d_{S}^\varepsilon(a,b)$</green> to be the shortest path metric on $\mathcal R^{(1)}_\varepsilon(S)$;

4. Denote by <green>$\mathcal{R}_\beta^\varepsilon(S)$</green> the Vietoris--Rips complex of $S$ under $d^\varepsilon_{S}$.

:::


:::{.column width="40%"}
![$\varepsilon$-path Metric on $S$](path-metric.png)
:::

:::

. . . 

::: {.callout-tip appearance="minimal"}
## Quasi-isometry [@Majhi2023]
For a dense enough sample $S$ of $\mathcal G$, $d^\varepsilon_{S}$ is <green>quasi-isometric</green> to the <green>length metric</green> on $\mathcal G$.

:::


## Remedy 2: <green>Large-scale</green> *Distortion* {.smaller}

:::{.columns}

:::{.column width="60%"}

- A finite sample around a corner does not see the corner
- <red>Global distortion</red>: $$\delta(\mathcal G)=\sup_{a\neq b}\frac{d^L_{\mathcal G}(a,b)}{\|a-b\|}$$
- <green>Large-scale distortion</green>: $$\delta^\varepsilon_R(\mathcal G)=\sup_{d^L(a,b)\geq R}\frac{d^L_{\mathcal G}(a,b)}{d^L_{\mathcal G^\varepsilon}(a,b)}$$
:::

:::{.column width="40%"}
![](graph.png){width="50%"}
:::

::::

. . . 

::: {.callout-tip appearance="minimal"}
## Limit [@2406.04259]
For any $R>0$, $\delta^\varepsilon_R(\mathcal G)\to1$ as $\varepsilon\to0$, <gray>provided $\mathcal G$ is compact</gray>.

:::

## Topological Reconstruction {.smaller}

:::{.callout-tip .nonincremental}
## Metric Graph Reconstruction [@graph_shadow]
<gray>Let $\mathcal G \subset \mathbb{R}^N$ be a compact, connected metric graph.  
Fix any $\xi\in\left(0,\frac{1}{4}\right)$.
For any positive $\beta<\frac{\ell(\mathcal G)}{4}$, choose a positive $\varepsilon\leq\frac{\beta}{3}$ such that $\delta^{\varepsilon}_{\beta}(\mathcal G)\leq\frac{1+2\xi}{1+\xi}$.</gray> 

If $S\subset \mathbb R^N$ is such that $d_H(\mathcal G,S)<\tfrac{1}{2}\xi\varepsilon$, then we have a homotopy equivalence <green>$\mathcal R^\varepsilon_\beta(S)\simeq \mathcal G$</green>.
:::

. . . 

Fixing <green>$\xi=1/6$</green>, we get a simpler but weaker statement.

:::{.callout-tip .nonincremental appearance="minimal"}
Let $\mathcal G \subset \mathbb{R}^N$ be a compact, connected metric graph.  
For any positive $\beta<\ell(\mathcal G)/4$, choose a positive $\varepsilon\leq\beta/3$ such that $\delta^{\varepsilon}_{\beta}(\mathcal G)\leq8/7$. 
If $S\subset \mathbb R^N$ and $d_H(\mathcal G,S)<\varepsilon/12$, then we have a homotopy equivalence $\mathcal R^\varepsilon_\beta(S)\simeq\mathcal G$.
:::


# <green>Geometric</green> Reconstruction {background-image="drawing.png" background-opacity="0.3"}

## Vietoris--Rips <green>Shadow</green> {.smaller}

:::{.columns}

:::{.column width="70%"}
- <green>Geometric reconstruction</green>: entails constructing <red>$\hat{\mathcal G}\subset\mathbb R^N$</red> from samples so that 
    - $\hat{\mathcal G}\simeq \mathcal G$ & $d_H(\hat{\mathcal G}, \mathcal G)$ is small

- Vietoris--Rips complexes are <red>abstract</red>, hence contain only topological information
- A good candidate for $\hat{\mathcal G}$ is the *shadow* of a topologically-faithful Vietoris--Rips.
:::


:::{.column width="30%"}

![$\mathcal K$](shadow-1.png){width="80%" fig-align="center"}

:::

:::


. . . 

:::{.columns}


:::{.column width="70%"}

- <green>Shadow</green>: For simplicial complex $\mathcal K$ with vertices from $\mathbb R^N$ is the union of the (Euclidean) convex hulls of simpices $\sigma\in\mathcal K$
  
- Notorious for being <red>topologically unfaithful</red>
    - @Chambers2010; @adamaszek_homotopy_2017

:::

:::{.column width="30%"}

![$\mathcal S(\mathcal K)$](shadow-2.png){width="80%" fig-align="center"}

:::

:::

## Vietoris--Rips Shadow in Limits {.smaller}

- $X\subset\mathbb R^N$ Euclidean metric space (Submanifolds, graphs; more generally ANR)
- Denote $$\pi_{m}(\mathcal{S}_\beta(\mathbb{S})) \coloneq  \lim_{S\in \mathbb{S}} \pi_{m}(S(\mathcal{R}_\beta (S)))$$
- We obtain an inverse system:
$$
\left\{ \pi_{m}(\mathcal{S}_{\gamma}(\mathbb{S})) \to \pi_{m}(\mathcal{S}_{\beta}(\mathbb{S})) \mid 0 < \gamma < \beta \right\}
$$
- The inverse limit group:
$$
\lim_{\beta} \pi_{m}(\mathcal{S}_{\beta}(\mathbb{S}))
$$

. . .

::: {.callout-tip icon="false"}
## Hausmann in Shadow Limits [@Kawamura2026-ob]
$$
\lim_{\beta} \pi_m(\mathcal{S}_\beta(\mathbb S)) \cong \pi_m(X).
$$
:::

## Graph Reconstruction via Shadow {.smaller}

::::{.callout-tip icon="false" .nonincremental style="font-size: 1em"}
## Geometric Reconstruction [@graph_shadow]
<gray>Let $\mathcal G \subset \mathbb{R}^2$ a graph.
Fix any $\xi\in\left(0,\frac{1-\Theta}{6}\right)$.
For any positive $\beta<\min\left\{\Delta(\mathcal G),\frac{\ell(\mathcal G)}{12}\right\}$, choose a positive $\varepsilon\leq\frac{(1-\Theta)(1-\Theta-6\xi)}{12}\beta$ such that $\delta^{\varepsilon}_{\beta}(\mathcal G)\leq\frac{1+2\xi}{1+\xi}$.</gray>

If $S\subset \mathbb R^2$ and $d_H(\mathcal G, S)<\tfrac{1}{2}\xi\varepsilon$, then the shadow $\mathcal{S}(\mathcal R_\beta^\varepsilon(S))$ is <green>homotopy equivalent</green> to $\mathcal G$. 
Moreover, <green>$d_H(\mathcal S(\mathcal R_\beta^\varepsilon(S)),\mathcal G)<\left(\beta+\frac{1}{2}\xi\varepsilon\right)$</green>. 
:::

- <green>$\Theta\in(0,1)$</green>: depends on the angles between tangents of edges at the graph vertices
- <green>$\Delta(G)$</green>: *Shadow radius* positive number for graphs with smooth edges
- $\mathcal G$ is <red>planar</red>

# Future Directions 

- The general case: <green>$\mathcal G\subset\mathbb R^N$</green>
    - *in preparation* with <green>Kazuhiro Kawamura</green> & <green>Atish Mitra</green>
- Use <green>discrete Morse theory</green> to perform *organized collapses* of higher dimensional simplices of shadow for homeomorphic reconstruction

- <green>Submanifold reconstruction</green> via Vietoris--Rips shadow

## References {background-image="drawing.png" background-opacity="0.3" style="font-size: 0.6em"}
